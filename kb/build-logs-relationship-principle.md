# Build-Logs Relationship Principle

## Learning
The `make check-logs` command only analyzes log files that are generated by `make build`. Running check-logs without a prior build provides no value since the log files haven't been updated. This relationship is critical for proper CI/CD workflow.

## Importance
Understanding this relationship prevents wasted effort and ensures accurate error detection:
- Log files are only updated during the build process
- check-logs reads these static files, it doesn't generate new ones
- Running check-logs repeatedly without rebuilding analyzes the same stale data
- CI builds fail if check-logs fails, so verification must happen after build

## Correct Workflow

### Primary Build Sequence
```bash
# MANDATORY sequence for development
make build 2>&1          # Generates fresh log files
make check-logs          # Analyzes the newly generated logs
```

### Clean Build Sequence
```bash
# When starting fresh or after major changes
make clean build 2>&1    # Clean, then build with fresh logs
make check-logs          # Analyze the new logs
```

## Common Mistakes

### Mistake 1: check-logs Without Build
```bash
# WRONG - analyzes stale logs
make check-logs
make check-logs  # Still analyzing the same old logs
```

### Mistake 2: check-logs Before Build
```bash
# WRONG - no logs exist yet
make clean
make check-logs  # No logs to check!
make build 2>&1
```

### Mistake 3: Assuming Logs Auto-Update
```bash
# WRONG - logs don't update automatically
# Edit source files...
make check-logs  # Still checking logs from last build!
```

## Log File Locations

The build process generates logs in:
```
logs/
├── run-tests.log           # Test execution output
├── sanitize-tests.log      # Sanitizer test output
├── tsan-tests.log          # Thread sanitizer output
├── build.log               # Main build output
└── *.log                   # Other module-specific logs
```

## CI/CD Integration

### GitHub Actions Workflow
```yaml
- name: Build
  run: make build 2>&1 | tee build.log
  
- name: Check logs
  run: make check-logs  # Must run AFTER build
```

### Pre-Commit Verification
```bash
# Before committing, ensure CI will pass
make clean build 2>&1
make check-logs  # Must succeed or CI will fail
```

## Debugging Check-Logs Failures

### Step 1: Identify the Error
```bash
make check-logs
# Output shows which log file and what error pattern
```

### Step 2: Examine the Specific Log
```bash
# Example: if run-tests.log has an error
grep -n "error\|ERROR" logs/run-tests.log
```

### Step 3: Update Whitelist if Intentional
```yaml
# log_whitelist.yaml
- file: "logs/run-tests.log"
  contains: "ERROR: Intentional test error"
```

### Step 4: Rebuild and Recheck
```bash
make build 2>&1  # Regenerate logs with fix
make check-logs  # Verify fix worked
```

## Best Practices

1. **Always build before check-logs**: Treat them as an atomic operation
2. **Clean build for major changes**: Use `make clean build` for fresh start
3. **Never skip check-logs**: It's your CI compatibility check
4. **Fix root causes**: Don't just whitelist errors, fix them when possible
5. **Document intentional errors**: Add clear comments in whitelist

## Related Patterns
- [Build Verification Before Commit](build-verification-before-commit.md)
- [Quick Start Commands](quick-start-commands.md)
- [CI Debugging Workflow](github-actions-debugging-workflow.md)
- [Build Log Verification Requirement](build-log-verification-requirement.md)