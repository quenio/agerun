# Ownership Gap Vulnerability Pattern

## Learning
Data can become corrupted when there's a temporal gap between one component dropping ownership and another taking it. During this vulnerable window, unowned data can be claimed by unintended components, leading to premature destruction and corruption.

## Importance
This vulnerability causes hard-to-debug corruption where data mysteriously changes type (e.g., MAP becoming INTEGER 0). Understanding this pattern prevents critical bugs in ownership transfer scenarios.

## Example
```c
// VULNERABLE: Gap between drop and take
ar_data_t* ar_agent__get_message(ar_agent_t *mut_agent) {
    ar_data_t *own_message = ar_list__remove_first(mut_agent->own_message_queue);
    if (own_message) {
        ar_data__drop_ownership(own_message, mut_agent);  // Message now unowned!
    }
    return own_message;  // Returning unowned data - VULNERABLE
}

// System receives unowned message
ar_data_t *own_message = ar_agency__get_agent_message(agent_id);
// ... passes to interpreter without taking ownership ...
ar_interpreter__execute_method(interpreter, agent_id, own_message);

// Meanwhile, expression evaluator claims the unowned message
const own_value = ar_data__claim_or_copy(ref_value, ref_frame);  // Claims unowned message!
// When destroyed, corrupts frame's reference

// FIX: System must take ownership immediately
if (own_message) {
    ar_data__take_ownership(own_message, mut_system);  // Close the gap!
    ar_interpreter__execute_method(mut_system->own_interpreter, agent_id, own_message);
    ar_data__destroy_if_owned(own_message, mut_system);
}
```

## Generalization
The ownership gap vulnerability occurs when:
1. Component A drops ownership of data
2. Time passes before Component B takes ownership
3. During this gap, Component C can claim the unowned data
4. Destruction by C corrupts references held by B

Prevention: Ensure atomic ownership transfer - new owner takes immediately after old owner drops.

## Implementation
```c
// Pattern 1: Atomic transfer within a function
ar_data_t* transfer_ownership(ar_data_t *own_data, void *old_owner, void *new_owner) {
    ar_data__drop_ownership(own_data, old_owner);
    ar_data__take_ownership(own_data, new_owner);  // No gap!
    return own_data;
}

// Pattern 2: Receiver takes ownership immediately
ar_data_t *own_message = ar_agent__get_message(agent);  // Returns unowned
ar_data__take_ownership(own_message, receiver);  // Immediate ownership

// Pattern 3: Document ownership state in function names
ar_data_t* ar_agent__get_message_unowned(ar_agent_t *agent);  // EXAMPLE: Hypothetical function name
ar_data_t* ar_agent__transfer_message_to(ar_agent_t *agent, void *new_owner);  // EXAMPLE: Hypothetical function
```

## Related Patterns
- [Message Ownership Flow](message-ownership-flow.md)
- [Ownership Drop in Message Passing](ownership-drop-message-passing.md)
- [Expression Ownership Rules](expression-ownership-rules.md)
- [Memory Debugging Comprehensive Guide](memory-debugging-comprehensive-guide.md)