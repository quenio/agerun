# AgeRun Interpreter Module

## Overview

The interpreter module provides execution capabilities for parsed instructions and methods in the AgeRun system. It implements the execution semantics for all instruction types defined in the AgeRun specification, working with Abstract Syntax Trees (ASTs) generated by the instruction module.

## Purpose

The interpreter module separates the execution logic from the parsing logic, following the principle of separation of concerns. While the instruction module parses instruction strings into AST nodes, the interpreter module executes these nodes, updating agent memory and managing control flow.

This separation provides several benefits:
- Eliminates circular dependencies that existed when parsing and execution were combined
- Allows for optimization of execution without affecting parsing
- Enables alternative execution strategies (e.g., compilation) in the future
- Improves testability by allowing execution logic to be tested independently

## Architecture

### Interpreter Structure
The interpreter uses an opaque type to hide implementation details. The interpreter structure includes:
- Reference to a log instance for error reporting
- Reference to a method evaluator for executing parsed methods

The design allows for future enhancements such as:
- Execution optimization flags
- Debugging capabilities
- Performance profiling
- Execution tracing

### Module Dependencies
```
ar_interpreter
├──c──> ar_log
├──c──> ar_method_evaluator (Zig)
├──c──> ar_agency
├──c──> ar_data
└──c──> ar_heap (Zig)
```

### Execution Model
The interpreter now delegates method execution to the method evaluator:
1. Retrieves the agent's method from the agency
2. Passes the method to the method evaluator
3. The method evaluator handles instruction parsing and execution
4. Returns success/failure status with error logging

## Supported Instructions

### Assignment
Executes assignment instructions of the form `memory.path := expression`.
- Evaluates the expression in the current context
- Takes ownership of the result
- Stores the value at the specified memory path
- Handles deep paths (e.g., `memory.x.y.z`)

### Send
Executes message sending instructions: `send(agent_id, message)`.
- Evaluates agent ID expression (must yield integer)
- Evaluates message expression
- Sends message to target agent (or discards if agent_id is 0)
- Optionally stores result in memory

### If
Executes conditional instructions: `if(condition, true_value, false_value)`.
- Evaluates condition expression
- Determines truthiness:
  - Integer: true if non-zero
  - Double: true if non-zero
  - String: true if non-empty
  - Map/List: always false (for safety)
- Evaluates and returns appropriate branch
- Implements lazy evaluation (only evaluates selected branch)

### Parse
Executes template parsing: `parse(template, input)`.
- Extracts variables from input string based on template pattern
- Template uses `{variable}` placeholders
- Automatically detects value types (integer, double, string)
- Returns map with extracted values

### Build
Executes string building: `build(template, values)`.
- Replaces `{variable}` placeholders in template with values from map
- Handles type conversion (integer/double to string)
- Supports dynamic string resizing for large results

### Method
Executes method creation: `method(name, instructions, version)`.
- Creates a new method with specified instructions
- Registers method in the methodology
- Handles version string conversion (integer to "X.0.0")
- Returns success indicator

### Agent
Executes agent creation: `agent(method_name, version, context)`.
- Creates new agent with specified method
- Provides initial context (can be empty/null)
- Returns agent ID (0 on failure)
- Handles version string conversion

### Destroy
Executes destruction operations:
- `destroy(agent_id)`: Destroys an agent
- `destroy(method_name, version)`: Unregisters a method
- Returns success indicator

## API Functions

The interpreter module provides a minimal public interface with just three functions:

### Core Functions

#### `ar_interpreter__create`
Creates a new interpreter instance.
- **Parameters**: Log instance for error reporting (borrowed reference)
- **Returns**: New interpreter or NULL on failure
- **Ownership**: Caller owns returned interpreter, borrows log reference

#### `ar_interpreter__destroy`
Destroys an interpreter instance.
- **Parameters**: Interpreter to destroy
- **Ownership**: Takes ownership and destroys

### Execution Functions

#### `ar_interpreter__execute_method`
Executes a complete method.
- **Parameters**:
  - Interpreter instance (mutable reference)
  - Agent ID (for memory/context access and method retrieval)
  - Message being processed (borrowed reference)
- **Returns**: true on success, false on failure
- **Process**:
  1. Retrieves method from agent using ar_agency__get_agent_method()
  2. Delegates execution to the method evaluator
  3. The method evaluator handles all parsing and execution
  4. Errors are logged through the log instance
  5. Returns the execution result

## Execution Semantics

### Expression Evaluation
All expressions are evaluated using the expression module:
- Memory access returns references (not owned)
- Arithmetic operations return new values (owned)
- String operations return new values (owned)
- The interpreter always takes ownership via `ar_expression__take_ownership`

### Memory Updates
Memory updates follow these rules:
- Assignment always stores a copy of the value
- Deep paths are created automatically if they don't exist
- Previous values are destroyed before storing new ones
- Memory is owned by the agent, not the interpreter

### Error Handling
The interpreter implements fail-fast error handling:
- Parsing errors stop execution immediately
- Type errors stop execution immediately
- Missing methods/agents return appropriate error values
- Memory allocation failures stop execution
- No partial execution - instructions are atomic

### Ownership Management
The interpreter strictly follows ownership rules:
- Always takes ownership of expression results
- Transfers ownership to appropriate destinations
- Cleans up temporary values
- Never leaks memory

## Implementation Details

### Simplified Architecture
The interpreter now has a much simpler implementation:
- Retrieves the agent's method from the agency
- Creates a method evaluator instance
- Delegates all execution to the method evaluator
- The method evaluator handles instruction parsing and execution
- Errors are logged through the provided log instance

### Method Evaluator Integration
The interpreter uses the Zig-based method evaluator which:
- Parses method instructions into ASTs
- Executes instructions sequentially
- Manages frames for execution context
- Handles all instruction types defined in the specification
- Provides comprehensive error reporting

### Memory Safety
The interpreter ensures memory safety through:
- Consistent ownership taking from expressions
- Proper cleanup in all error paths
- Clear ownership documentation
- Use of heap tracking macros

## Usage Example

```c
// Create a log instance for error reporting
ar_log_t *log = ar_log__create();

// Create interpreter with log
ar_interpreter_t *interpreter = ar_interpreter__create(log);

// Execute method for an agent
// The method is retrieved automatically from the agent
bool success = ar_interpreter__execute_method(
    interpreter,
    agent_id,
    message
);

// Check for errors
if (!success) {
    ar_event_t *error = ar_log__get_last_error(log);
    if (error) {
        printf("Error: %s\n", ar_event__get_message(error));
    }
}

// Cleanup
ar_interpreter__destroy(interpreter);
ar_log__destroy(log);
```

## Design Decisions

### Separation from Parsing
The interpreter is completely separate from parsing logic. This allows:
- Independent testing of execution logic
- Alternative parsing strategies without affecting execution
- Cleaner module dependencies

### Stateless Design
The interpreter is currently stateless (execution context comes from parameters). This allows:
- Thread-safe execution (with proper context isolation)
- Simple implementation
- Easy testing

### AST-Based Execution
Working with ASTs rather than raw strings provides:
- Single parsing pass
- Type-safe instruction handling
- Potential for optimization

### Consistent Ownership
Always taking ownership from expressions simplifies:
- Memory management
- Error handling
- Testing

## Comparison with Old Implementation

The refactored interpreter differs from the old combined instruction module:

| Aspect | Old Implementation | New Implementation |
|--------|-------------------|-------------------|
| Architecture | Parse and execute together | Separate parsing and execution |
| Dependencies | Circular dependencies | Clean, unidirectional |
| Testing | Mixed concerns | Focused execution tests |
| Extensibility | Limited | Easy to add new execution strategies |
| Memory Model | Same ownership rules | Same ownership rules (compatibility) |

## Future Enhancements

Potential improvements:
- **Optimization**: Cache parsed methods for faster execution
- **Debugging**: Add execution tracing and breakpoints
- **Compilation**: Generate bytecode instead of tree-walking
- **Parallelism**: Execute independent instructions concurrently
- **Error Recovery**: Continue execution after certain errors
- **Profiling**: Track execution time per instruction

## Memory Management

The interpreter follows the AgeRun Memory Management Model:
- Takes ownership of expression results via `ar_expression__take_ownership`
- Transfers ownership to storage locations (memory, agency)
- Cleans up all temporary values
- Uses heap tracking macros for all allocations
- Achieves zero memory leaks

## Error Handling

The interpreter provides comprehensive error handling through the log instance:
- Returns false on any execution error
- Logs detailed error messages through the provided ar_log instance
- The method evaluator provides specific error messages for each failure type
- Fails fast on any error condition
- Errors can be retrieved using ar_log__get_last_error()

## Thread Safety

The interpreter is thread-safe when:
- Each thread has its own interpreter instance
- Instruction contexts are not shared between threads
- Agent memory access is properly synchronized
- System-level operations are thread-safe

Note: The current system is single-threaded, but the design supports future multi-threading.