# AgeRun Interpreter Module

## Overview

The interpreter module provides execution capabilities for parsed instructions and methods in the AgeRun system. It implements the execution semantics for all instruction types defined in the AgeRun specification, working with Abstract Syntax Trees (ASTs) generated by the instruction module.

## Purpose

The interpreter module separates the execution logic from the parsing logic, following the principle of separation of concerns. While the instruction module parses instruction strings into AST nodes, the interpreter module executes these nodes, updating agent memory and managing control flow.

This separation provides several benefits:
- Eliminates circular dependencies that existed when parsing and execution were combined
- Allows for optimization of execution without affecting parsing
- Enables alternative execution strategies (e.g., compilation) in the future
- Improves testability by allowing execution logic to be tested independently

## Architecture

### Interpreter Structure
The interpreter uses an opaque type to hide implementation details. Currently, the structure is minimal as the interpreter is stateless, but the design allows for future enhancements such as:
- Execution optimization flags
- Debugging capabilities
- Performance profiling
- Execution tracing

### Module Dependencies
```
ar_interpreter
    ├── uses → ar_instruction (for parsing and AST access)
    ├── uses → ar_expression (for expression evaluation)
    ├── uses → ar_agency (for agent operations)
    ├── uses → ar_methodology (for method operations)
    ├── uses → ar_data (for data manipulation)
    ├── uses → ar_string (for string operations)
    ├── uses → ar_map (for map operations)
    └── uses → ar_heap (for memory tracking)
```

### Execution Model
The interpreter implements a tree-walking execution model:
1. Receives parsed instruction AST from the instruction module
2. Traverses the AST to determine instruction type
3. Executes the appropriate operation
4. Returns success/failure status

## Supported Instructions

### Assignment
Executes assignment instructions of the form `memory.path := expression`.
- Evaluates the expression in the current context
- Takes ownership of the result
- Stores the value at the specified memory path
- Handles deep paths (e.g., `memory.x.y.z`)

### Send
Executes message sending instructions: `send(agent_id, message)`.
- Evaluates agent ID expression (must yield integer)
- Evaluates message expression
- Sends message to target agent (or discards if agent_id is 0)
- Optionally stores result in memory

### If
Executes conditional instructions: `if(condition, true_value, false_value)`.
- Evaluates condition expression
- Determines truthiness:
  - Integer: true if non-zero
  - Double: true if non-zero
  - String: true if non-empty
  - Map/List: always false (for safety)
- Evaluates and returns appropriate branch
- Implements lazy evaluation (only evaluates selected branch)

### Parse
Executes template parsing: `parse(template, input)`.
- Extracts variables from input string based on template pattern
- Template uses `{variable}` placeholders
- Automatically detects value types (integer, double, string)
- Returns map with extracted values

### Build
Executes string building: `build(template, values)`.
- Replaces `{variable}` placeholders in template with values from map
- Handles type conversion (integer/double to string)
- Supports dynamic string resizing for large results

### Method
Executes method creation: `method(name, instructions, version)`.
- Creates a new method with specified instructions
- Registers method in the methodology
- Handles version string conversion (integer to "X.0.0")
- Returns success indicator

### Agent
Executes agent creation: `agent(method_name, version, context)`.
- Creates new agent with specified method
- Provides initial context (can be empty/null)
- Returns agent ID (0 on failure)
- Handles version string conversion

### Destroy
Executes destruction operations:
- `destroy(agent_id)`: Destroys an agent
- `destroy(method_name, version)`: Unregisters a method
- Returns success indicator

## API Functions

### Core Functions

#### `ar_interpreter__create`
Creates a new interpreter instance.
- **Returns**: New interpreter or NULL on failure
- **Ownership**: Caller owns returned interpreter

#### `ar_interpreter__destroy`
Destroys an interpreter instance.
- **Parameters**: Interpreter to destroy
- **Ownership**: Takes ownership and destroys

### Execution Functions

#### `ar_interpreter__execute_instruction`
Executes a single instruction string.
- **Parameters**:
  - Interpreter instance
  - Instruction context (memory, context, message)
  - Instruction string
- **Returns**: true on success, false on failure
- **Process**:
  1. Parses instruction to AST
  2. Executes based on instruction type
  3. Cleans up AST
  4. Returns result

#### `ar_interpreter__execute_method`
Executes a complete method.
- **Parameters**:
  - Interpreter instance
  - Agent ID (for memory/context access)
  - Message being processed
  - Method to execute
- **Returns**: true on success, false on failure
- **Process**:
  1. Creates instruction context
  2. Splits method instructions by newlines
  3. Executes each instruction sequentially
  4. Stops on first failure
  5. Cleans up resources

## Execution Semantics

### Expression Evaluation
All expressions are evaluated using the expression module:
- Memory access returns references (not owned)
- Arithmetic operations return new values (owned)
- String operations return new values (owned)
- The interpreter always takes ownership via `ar_expression__take_ownership`

### Memory Updates
Memory updates follow these rules:
- Assignment always stores a copy of the value
- Deep paths are created automatically if they don't exist
- Previous values are destroyed before storing new ones
- Memory is owned by the agent, not the interpreter

### Error Handling
The interpreter implements fail-fast error handling:
- Parsing errors stop execution immediately
- Type errors stop execution immediately
- Missing methods/agents return appropriate error values
- Memory allocation failures stop execution
- No partial execution - instructions are atomic

### Ownership Management
The interpreter strictly follows ownership rules:
- Always takes ownership of expression results
- Transfers ownership to appropriate destinations
- Cleans up temporary values
- Never leaks memory

## Implementation Details

### Instruction Dispatch
The interpreter uses a switch statement for instruction dispatch:
```c
switch (instruction_type) {
    case AR_INSTRUCTION_TYPE__ASSIGNMENT: return _execute_assignment(...);
    case AR_INSTRUCTION_TYPE__SEND: return _execute_send(...);
    // ... etc
}
```

### Helper Functions
Each instruction type has a dedicated execution function:
- `_execute_assignment`: Handles memory assignment
- `_execute_send`: Handles message sending
- `_execute_if`: Handles conditionals
- `_execute_parse`: Handles template parsing
- `_execute_build`: Handles string building
- `_execute_method`: Handles method creation
- `_execute_agent`: Handles agent creation
- `_execute_destroy`: Handles destruction

### Memory Safety
The interpreter ensures memory safety through:
- Consistent ownership taking from expressions
- Proper cleanup in all error paths
- Clear ownership documentation
- Use of heap tracking macros

## Usage Example

```c
// Create interpreter
ar_interpreter_t *interpreter = ar_interpreter__create();

// Create instruction context
ar_instruction_context_t *ctx = ar_instruction__create_context(
    agent_memory,    // Mutable memory reference
    agent_context,   // Context reference
    message         // Message reference (can be NULL)
);

// Execute single instruction
bool success = ar_interpreter__execute_instruction(
    interpreter,
    ctx,
    "memory.result := 2 + 2"
);

// Execute method
const ar_method_t *method = ar_methodology__get_method("calculator", "1.0.0");
success = ar_interpreter__execute_method(
    interpreter,
    agent_id,
    message,
    method
);

// Cleanup
ar_instruction__destroy_context(ctx);
ar_interpreter__destroy(interpreter);
```

## Design Decisions

### Separation from Parsing
The interpreter is completely separate from parsing logic. This allows:
- Independent testing of execution logic
- Alternative parsing strategies without affecting execution
- Cleaner module dependencies

### Stateless Design
The interpreter is currently stateless (execution context comes from parameters). This allows:
- Thread-safe execution (with proper context isolation)
- Simple implementation
- Easy testing

### AST-Based Execution
Working with ASTs rather than raw strings provides:
- Single parsing pass
- Type-safe instruction handling
- Potential for optimization

### Consistent Ownership
Always taking ownership from expressions simplifies:
- Memory management
- Error handling
- Testing

## Comparison with Old Implementation

The refactored interpreter differs from the old combined instruction module:

| Aspect | Old Implementation | New Implementation |
|--------|-------------------|-------------------|
| Architecture | Parse and execute together | Separate parsing and execution |
| Dependencies | Circular dependencies | Clean, unidirectional |
| Testing | Mixed concerns | Focused execution tests |
| Extensibility | Limited | Easy to add new execution strategies |
| Memory Model | Same ownership rules | Same ownership rules (compatibility) |

## Future Enhancements

Potential improvements:
- **Optimization**: Cache parsed methods for faster execution
- **Debugging**: Add execution tracing and breakpoints
- **Compilation**: Generate bytecode instead of tree-walking
- **Parallelism**: Execute independent instructions concurrently
- **Error Recovery**: Continue execution after certain errors
- **Profiling**: Track execution time per instruction

## Memory Management

The interpreter follows the AgeRun Memory Management Model:
- Takes ownership of expression results via `ar_expression__take_ownership`
- Transfers ownership to storage locations (memory, agency)
- Cleans up all temporary values
- Uses heap tracking macros for all allocations
- Achieves zero memory leaks

## Error Handling

The interpreter provides basic error handling:
- Returns false on any execution error
- Relies on instruction context for detailed error reporting
- Does not provide its own error messages
- Fails fast on any error condition

## Thread Safety

The interpreter is thread-safe when:
- Each thread has its own interpreter instance
- Instruction contexts are not shared between threads
- Agent memory access is properly synchronized
- System-level operations are thread-safe

Note: The current system is single-threaded, but the design supports future multi-threading.